package kmon

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/phuslu/log"
	"github.com/pliu/kmon/pkg/clients"
	"github.com/pliu/kmon/pkg/config"
	"github.com/pliu/kmon/pkg/utils"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/twmb/franz-go/pkg/kgo"
)

type Monitor struct {
	producerClient   clients.KgoClient
	producerTopic    string
	consumerClient   clients.KgoClient
	instanceUUID     string
	partitions       int
	p2bStats         map[int]*utils.Stats
	b2cStats         map[int]*utils.Stats
	e2eStats         map[int]*utils.Stats
	producerAckStats map[int]*utils.Stats
	sampleFrequency  time.Duration
}

func NewMonitorWithClients(producerClient clients.KgoClient, producerTopic string, consumerClient clients.KgoClient, instanceUUID string, partitions int, sampleFrequency time.Duration, statsWindow time.Duration) *Monitor {
	m := &Monitor{
		producerClient:  producerClient,
		producerTopic:   producerTopic,
		consumerClient:  consumerClient,
		instanceUUID:    instanceUUID,
		partitions:      partitions,
		sampleFrequency: sampleFrequency,
	}
	m.p2bStats = make(map[int]*utils.Stats)
	m.b2cStats = make(map[int]*utils.Stats)
	m.e2eStats = make(map[int]*utils.Stats)
	m.producerAckStats = make(map[int]*utils.Stats)
	for p := range m.partitions {
		m.p2bStats[p] = utils.NewStats(statsWindow)
		m.b2cStats[p] = utils.NewStats(statsWindow)
		m.e2eStats[p] = utils.NewStats(statsWindow)
		m.producerAckStats[p] = utils.NewStats(statsWindow)
	}
	return m
}

// TODO: Cross-cluster measurements should ignore partitions on e2e and not measure b2c
func NewMonitorFromConfig(cfg *config.KMonConfig, partitions int) (*Monitor, error) {
	var producerClient *kgo.Client
	var consumerClient *kgo.Client
	var err error

	if cfg.ConsumerKafkaConfig == nil {
		producerClient, err = clients.GetFranzGoClient(cfg.ProducerKafkaConfig, cfg.ProducerMonitoringTopic)
		if err != nil {
			return nil, err
		}
		consumerClient = producerClient
	} else {
		producerClient, err = clients.GetFranzGoClient(cfg.ProducerKafkaConfig)
		if err != nil {
			return nil, err
		}
		consumerClient, err = clients.GetFranzGoClient(cfg.ConsumerKafkaConfig, cfg.ConsumerMonitoringTopic)
		if err != nil {
			producerClient.Close()
			return nil, err
		}
	}

	instanceUUID := uuid.NewString()

	return NewMonitorWithClients(producerClient, cfg.ProducerMonitoringTopic, consumerClient, instanceUUID, partitions, time.Duration(cfg.GetSampleFrequencyMs())*time.Millisecond, time.Duration(cfg.GetStatsWindowSeconds())*time.Second), nil
}

func (m *Monitor) Start(ctx context.Context) {
	defer m.producerClient.Close()
	if m.consumerClient != m.producerClient {
		defer m.consumerClient.Close()
	}
	log.Info().Msgf("Starting monitor instance %s", m.instanceUUID)

	m.warmup(ctx)

	go m.consumeLoop(ctx)
	go m.updateQuantilesLoop(ctx)

	ticker := time.NewTicker(m.sampleFrequency)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			log.Info().Msgf("Stopping monitor instance %s", m.instanceUUID)
			return
		case <-ticker.C:
			m.publishProbeBatch(ctx)
		}
	}
}

func (m *Monitor) warmup(ctx context.Context) {
	m.publishProbeBatch(ctx)
	time.Sleep(3 * time.Second)
}

func (m *Monitor) publishProbeBatch(ctx context.Context) {
	for partition := range m.partitions {
		m.publishProbe(ctx, partition)
	}
}

func (m *Monitor) publishProbe(ctx context.Context, partition int) {
	sentAt := time.Now()
	record := &kgo.Record{
		Topic:     m.producerTopic,
		Partition: int32(partition),
		Key:       []byte(m.instanceUUID),
		Value:     fmt.Appendf(nil, "%d", sentAt.UnixNano()),
	}

	partitionLabel := m.partitionLabel(partition)

	m.producerClient.Produce(ctx, record, func(r *kgo.Record, err error) {
		if err != nil {
			ProduceMessageFailureCount.WithLabelValues(partitionLabel).Inc()
			return
		}

		m.producerAckStats[partition].Add(time.Since(sentAt).Milliseconds())
		ProduceMessageCount.WithLabelValues(partitionLabel).Inc()
	})
}

func (m *Monitor) consumeLoop(ctx context.Context) {
	for {
		fetches := m.consumerClient.PollFetches(ctx)

		select {
		case <-ctx.Done():
			return
		default:
			if fetches.IsClientClosed() {
				return
			}

			fetches.EachError(func(topic string, partition int32, err error) {
				ConsumeMessageCount.WithLabelValues(m.partitionLabel(int(partition))).Inc()
			})

			now := time.Now()
			fetches.EachRecord(func(record *kgo.Record) {
				m.handleConsumedRecord(record, now)
			})
		}
	}
}

func (m *Monitor) handleConsumedRecord(record *kgo.Record, consumeTime time.Time) {
	// Only process messages that were generated by this instance
	if string(record.Key) != m.instanceUUID {
		return
	}

	timestamp, err := strconv.ParseInt(string(record.Value), 10, 64)
	if err != nil {
		// TODO: Log, metric?
		return
	}
	sentAt := time.Unix(0, timestamp)

	partition := int(record.Partition)
	partitionLabel := m.partitionLabel(partition)

	m.b2cStats[partition].Add(consumeTime.Sub(record.Timestamp).Milliseconds())
	m.e2eStats[partition].Add(consumeTime.Sub(sentAt).Milliseconds())
	m.p2bStats[partition].Add(record.Timestamp.Sub(sentAt).Milliseconds())

	ConsumeMessageCount.WithLabelValues(partitionLabel).Inc()
}

func (m *Monitor) partitionLabel(partition int) string {
	return fmt.Sprintf("%d", partition)
}

func (m *Monitor) updateQuantilesLoop(ctx context.Context) {
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			for partition := range m.partitions {
				partitionLabel := m.partitionLabel(partition)
				m.updateQuantiles(m.e2eStats[partition], E2EMessageLatencyQuantile, partitionLabel)
				m.updateQuantiles(m.p2bStats[partition], P2BMessageLatencyQuantile, partitionLabel)
				m.updateQuantiles(m.b2cStats[partition], B2CMessageLatencyQuantile, partitionLabel)
				m.updateQuantiles(m.producerAckStats[partition], ProducerAckLatencyQuantile, partitionLabel)
			}
		}
	}
}

func (m *Monitor) updateQuantiles(stats *utils.Stats, gauge *prometheus.GaugeVec, partitionLabel string) {
	res, ok := stats.Percentile([]float64{50, 95, 99})
	if !ok {
		return
	}
	gauge.WithLabelValues(partitionLabel, "p50").Set(float64(res[0]))
	gauge.WithLabelValues(partitionLabel, "p95").Set(float64(res[1]))
	gauge.WithLabelValues(partitionLabel, "p99").Set(float64(res[2]))
}
